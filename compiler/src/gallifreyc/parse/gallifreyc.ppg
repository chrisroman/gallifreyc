// Assumes polyglot.jar is in classpath
include "polyglot/ext/jl7/parse/jl7.ppg"

package gallifreyc.parse;

import gallifreyc.types.GallifreyTypeSystem;
import gallifreyc.ast.GallifreyNodeFactory;
import gallifreyc.ast.*;
import polyglot.parse.Name;
import polyglot.parse.VarDeclarator;

parser Grm extends polyglot.ext.jl7.parse.Grm {:
    public final GallifreyTypeSystem ts;
    public final GallifreyNodeFactory nf;

    public Grm(Lexer l, TypeSystem t, NodeFactory n, ErrorQueue q) {
        super(l, t, n, q);
        ts = (GallifreyTypeSystem) t;
        nf = (GallifreyNodeFactory) n;
    }
:};

terminal Token ALLOWS;
terminal Token BRANCH;
terminal Token CONTINGENT;
terminal Token DELETE;
terminal Token ENSURES;
terminal Token LOCAL;
terminal Token MATCH_RESTRICTION;
terminal Token MERGE;
terminal Token REQUIRES;
terminal Token RESTRICTION;
terminal Token SHARED;
terminal Token TEST;
terminal Token THREAD;
terminal Token TRANSITION;
terminal Token UNIQUE;
terminal Token WHEN;
terminal Token WHERE;
terminal Token WITH;

non terminal PreCondition pre_condition_opt;
non terminal PostCondition post_condition_opt;
non terminal RefQualification ref_qualification;

start with goal;

// Reference Qualifications (local, unique, shared)
// TODO: Add example, fix result types
override type ::=
    // TypeNode
    primitive_type:a
{: RESULT = a; :}
|   ref_qualification:r reference_type:a
{:
 //RESULT = parser.nf.RefQualifiedTypeNode(parser.pos(r, a), r, a);
 RESULT = a;
 :}
;

ref_qualification ::=
    // RefQualification
    LOCAL:a
{: RESULT = parser.nf.LocalRef(parser.pos(a)); :}
| UNIQUE:a
{: RESULT = parser.nf.UniqueRef(parser.pos(a)); :}
| SHARED:a LBRACK IDENTIFIER:b RBRACK:c
{: RESULT = parser.nf.SharedRef(parser.pos(a,c),
                                parser.nf.Id(parser.pos(b), b.getIdentifier())); :}
;

// Pre/post conditions on method declarations in interfaces
override abstract_method_declaration ::=
    // MethodDecl
    method_header:a pre_condition_opt:b post_condition_opt:c SEMICOLON
{: RESULT = parser.nf.MethodDecl(a.position(), a, b, c); :}
;

pre_condition_opt ::=
    // PreCondition
    {: RESULT = null; :}
    | REQUIRES:a expression:b
    {: RESULT = parser.nf.PreCondition(parser.pos(a, b), b); :}
;

post_condition_opt ::=
    // PostCondition
    {: RESULT = null; :}
    | ENSURES:a expression:b
    {: RESULT = parser.nf.PostCondition(parser.pos(a, b), b); :}
;


// TODO: modify the default Java grammar using PPG operations
